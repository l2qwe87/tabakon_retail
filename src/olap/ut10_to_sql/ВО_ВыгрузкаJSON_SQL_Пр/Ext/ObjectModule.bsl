перем Соединение;
перем ИмяСервераSQL;
перем ПользовательSQL;
перем ПарольSQL;
перем БазаДанныхSQL;

Функция НачатьВыгрузку() ЭКСПОРТ
	
	Время1 = ТекущаяДата();
	Для Каждого опция из ЭтотОбъект.ОпцииВыгрузки Цикл
		Если опция.Выбран Тогда
			Если ЭтотОбъект.ПараллельнаяВыгрузка Тогда
				ВыгрузкаПоОпцииВФоне(опция.ИдентификаторОпции, НачалоДня(ЭтотОбъект.ДатаНачала), КонецДня(ЭтотОбъект.ДатаОкончания));
			Иначе
				ВыгрузкаПоОпции(опция.ИдентификаторОпции, НачалоДня(ЭтотОбъект.ДатаНачала), КонецДня(ЭтотОбъект.ДатаОкончания));
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;   
	
	
	Если ЭтотОбъект.ПараллельнаяВыгрузка Тогда
		вФоне = ПолучитьКоличествоФоновыхПроцессов();
		Пока вФоне > 0 Цикл
			Пауза(10);  
			вФоне = ПолучитьКоличествоФоновыхПроцессов();
		КонецЦикла;
	КонецЕсли;
	
	Время2 = ТекущаяДата(); 
	дюрейшин = "" + "("+Формат(Дата(1,1,1,0,0,0)+(Время2 - Время1),"ДЛФ=В")+")";
	Сообщить("Окончание " + датаОкончания + дюрейшин);
	
	Если Соединение <> неопределено Тогда
		Соединение.Close();
		Соединение = неопределено;
	КонецЕсли;
КонецФункции


Функция ВыгрузкаПоОпции(идентификаторОпции, датаНачала, датаОкончания)
	Время1 = ТекущаяДата();
	Сообщить("Начало "+идентификаторОпции+" "+ датаНачала + " - " + датаОкончания);
	
	Если Лев(идентификаторОпции, 11) = "Справочник_" Тогда
		ВыгрузитьСправочник(идентификаторОпции, датаНачала, датаОкончания);
	ИначеЕсли Лев(идентификаторОпции, 9) = "Документ_" Тогда 
		ВыгрузитьДокументы(идентификаторОпции, датаНачала, датаОкончания)
	ИначеЕсли Лев(идентификаторОпции, 7) = "Регистр" Тогда 
		ВыгрузитьДокументы(идентификаторОпции, датаНачала, датаОкончания)	
	Иначе
	КонецЕсли;                                                                   
	
	Время2 = ТекущаяДата(); 
	дюрейшин = "" + "("+Формат(Дата(1,1,1,0,0,0)+(Время2 - Время1),"ДЛФ=В")+")";

	Сообщить("Окончание "+идентификаторОпции+" "+ датаНачала + " - " + датаОкончания + дюрейшин);
КонецФункции               


Функция ВыгрузитьДокументы(идентификаторОпции, датаНачала, датаОкончания)
	//
	_датаН = датаНачала;
	_датаК = КонецДня(датаНачала);
	шагВДнях = 1; 
	
	скд = ЭтотОбъект.ПолучитьМакет(идентификаторОпции);
	Если НЕ СКДСодержитПараметрДатаНиДатаК(скд) Тогда
		_датаН = датаОкончания - 1;
		_датаК = датаОкончания;
	КонецЕсли;  
	
	
	Если СКДСодержитПараметрМагазин(скд)Тогда 
		мСклады = ПолучитьМассивСкладов();
	Иначе                                 
		мСклады = новый Массив;
		мСклады.Добавить(неопределено);
	КонецЕсли;
	
	Пока _датаН < датаОкончания Цикл        
		
		Для Каждого склад из мСклады Цикл
			_ВыгрузитьДокументы(идентификаторОпции, _датаН, _датаК, склад);
		КонецЦикла;                                                      
		
		_датаН = КонецДня(_датаК)+1;	
		_датаК = КонецДня(_датаК + 60*60*24*шагВДнях);
		Если _датаК > датаОкончания Тогда
			_датаК = датаОкончания;
		КонецЕсли;
	КонецЦикла;
КонецФункции

Функция _ВыгрузитьДокументы(идентификаторОпции, датаНачала, датаОкончания, склад)
	скд = ЭтотОбъект.ПолучитьМакет(идентификаторОпции);
	Если ЛОЖЬ Тогда скд = новый СхемаКомпоновкиДанных; КонецЕсли;   
	
	параметрыСКД = новый Структура();
	параметрыСКД.Вставить("ДатаН",датаНачала);
	параметрыСКД.Вставить("ДатаК",датаОкончания);
	параметрыСКД.Вставить("Магазин",склад);
	
	// 
	параметрыСКД.Вставить("Ильина",Справочники.Контрагенты.НайтиПоКоду("АВ0012017"));
	параметрыСКД.Вставить("Трубач",Справочники.Контрагенты.НайтиПоКоду("АВ0000149"));
	параметрыСКД.Вставить("Ульянова",Справочники.Контрагенты.НайтиПоКоду("АВ0012069"));
	параметрыСКД.Вставить("НаименованиеДоговора","ЗАКРЫТ");
	параметрыСКД.Вставить("КонтрагентПДВ",Справочники.Контрагенты.НайтиПоКоду("АВ0000254"));
	параметрыСКД.Вставить("ОрганизацияТабакон",Справочники.Организации.НайтиПоКоду("000000100"));
	//
	
	тз = ПолучитьДанныеПоСКД(скд,параметрыСКД);
	
	массивДанных = ТаблицаЗначенийВМассивДанных(тз, истина);
	
	суфиксТмп = ""+ДатуВСтрокуСКЛ(датаНачала)+"_"+ДатуВСтрокуСКЛ(датаОкончания)+строка(склад);
	
	Условие = " 1=1 ";
	Если СКДСодержитПараметрДатаНиДатаК(скд) Тогда
		Условие = Условие + " AND " + " [Дата] >= '"+ДатуВСтрокуСКЛ(датаНачала)+"' AND [Дата] <= '"+ДатуВСтрокуСКЛ(датаОкончания)+"' "
	КонецЕсли;      
	
	Если СКДСодержитПараметрМагазин(скд) Тогда
		уиСклада = склад.УникальныйИдентификатор();
		Условие = Условие + " AND " + " [Магазин] = '"+уиСклада+"' "
	КонецЕсли;
	
	ДанныеВСиквел(
		массивДанных,
		СтрЗаменить(СтрЗаменить(СтрЗаменить(идентификаторОпции,"__",":"),"_",""),":","_"),
		Условие,
		ложь,
		суфиксТмп		
	);       
	
	//поиск связанного
	
	идентификаторОпцииДляПоиска = СтрЗаменить(идентификаторОпции,"_Основной","");
	Для Каждого макет из ЭтотОбъект.Метаданные().Макеты Цикл
		Если 
			Строка(макет.ТипМакета) = "СхемаКомпоновкиДанных"
			И ОбщегоНазначения.СтрНайти_Общая(макет.Имя,идентификаторОпцииДляПоиска) > 0 
			И Прав(макет.Имя,9) <> "_Основной" 
			Тогда
			
			Для Каждого элемент из тз Цикл 
				_ВыгрузитьДокументы_Связанный(макет.Имя, датаНачала, датаОкончания, элемент.Ссылка)
			КонецЦикла;	
		КонецЕсли;
	КонецЦикла;
КонецФункции 

Функция _ВыгрузитьДокументы_Связанный(идентификаторОпции, датаНачала, датаОкончания, ссылкаВладелец)
	скд = ЭтотОбъект.ПолучитьМакет(идентификаторОпции);
	Если ЛОЖЬ Тогда скд = новый СхемаКомпоновкиДанных; КонецЕсли;   
	
	параметрыСКД = новый Структура();
	параметрыСКД.Вставить("СсылкаВладелец",ссылкаВладелец);
	
	тз = ПолучитьДанныеПоСКД(скд,параметрыСКД);
	
	массивДанных = ТаблицаЗначенийВМассивДанных(тз);
	
	ссылкаВладелецУИ = Строка(ссылкаВладелец.УникальныйИдентификатор());
	суфиксТмп = ""+ДатуВСтрокуСКЛ(датаНачала)+"_"+ДатуВСтрокуСКЛ(датаОкончания)+"_"+ссылкаВладелецУИ;
	ДанныеВСиквел(
		массивДанных,
		СтрЗаменить(СтрЗаменить(СтрЗаменить(идентификаторОпции,"__",":"),"_",""),":","_"),
		" [СсылкаВладелец] ='"+ссылкаВладелецУИ+"' ",
		ложь,
		суфиксТмп		
	);

КонецФункции




Функция ВыгрузитьСправочник(идентификаторОпции, датаНачала, датаОкончания)
	_ВыгрузитьСправочник(идентификаторОпции, датаНачала, датаОкончания);
КонецФункции

Функция _ВыгрузитьСправочник(идентификаторОпции, датаНачала, датаОкончания)
		скд = ЭтотОбъект.ПолучитьМакет(идентификаторОпции);
	Если ЛОЖЬ Тогда скд = новый СхемаКомпоновкиДанных; КонецЕсли;   
	
	параметрыСКД = новый Структура();	
	тз = ПолучитьДанныеПоСКД(скд,параметрыСКД);
	
	массивДанных = ТаблицаЗначенийВМассивДанных(тз, ложь);
	
	суфиксТмп = ""+ДатуВСтрокуСКЛ(датаНачала)+"_"+ДатуВСтрокуСКЛ(датаОкончания);
	ДанныеВСиквел(
		массивДанных,
		СтрЗаменить(СтрЗаменить(СтрЗаменить(идентификаторОпции,"__",":"),"_",""),":","_"),
		,
		ИСТИНА);  
КонецФункции

Функция СКДСодержитПараметрМагазин(скд)  
	резалт = ложь;
	Если скд.Параметры.Найти("Магазин") <> неопределено Тогда
		резалт = истина;
	КонецЕсли;
	возврат резалт;
КонецФункции  

Функция СКДСодержитПараметрДатаНиДатаК(скд)  
	резалт = ложь;
	Если (скд.Параметры.Найти("ДатаН") <> неопределено) и (скд.Параметры.Найти("ДатаК") <> неопределено)  Тогда
		резалт = истина;
	КонецЕсли;
	возврат резалт;
КонецФункции  

Функция ПолучитьМассивСкладов()
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ Ссылка ИЗ Справочник.Склады ГДЕ Наименование = ""МегаДыбенкоПДВ""";
	мСклады = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	Возврат мСклады;
КонецФункции


Функция ПолучитьДанныеПоСКД(скд, параметрыСКД) 
	///Из схемы возьмем настройки по умолчанию
    Настройки = скд.НастройкиПоУмолчанию;
    
    //Помещаем в переменную данные о расшифровке данных
    ДанныеРасшифровки = Новый ДанныеРасшифровкиКомпоновкиДанных;
    
    //Формируем макет, с помощью компоновщика макета
    КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
    
    //Передаем в макет компоновки схему, настройки и данные расшифровки
    МакетКомпоновки = КомпоновщикМакета.Выполнить(скд, Настройки, , , Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));
	
	Если ЛОЖЬ Тогда параметрыСКД = новый Структура; КонецЕсли;   
	Для Каждого эл из параметрыСКД Цикл
		парам = МакетКомпоновки.ЗначенияПараметров.Найти(эл.Ключ);
		Если парам <> неопределено Тогда
			парам.Значение = эл.Значение;
		КонецЕсли;
	КонецЦикла;    
    //Выполним компоновку с помощью процессора компоновки
    ПроцессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
    //ПроцессорКомпоновкиДанных.Инициализировать(МакетКомпоновки, , ДанныеРасшифровки);
    ПроцессорКомпоновкиДанных.Инициализировать(МакетКомпоновки);
    
    ДеревоРезультата = Новый ТаблицаЗначений;
    
    ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
    ПроцессорВывода.УстановитьОбъект(ДеревоРезультата);
    ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных);
	
	Возврат ДеревоРезультата;
КонецФункции

////
Функция РазобратьПараметры(_парамс) ЭКСПОРТ 
	парамс = _парамс;	
	парамс = СтрЗаменить(парамс, "  ", " ");
		
	мПараметры = ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(парамс, " ");
	Если ЛОЖЬ Тогда мПараметры = новый Массив; КонецЕсли;
	
	инд = 0;
	всего = мПараметры.Количество();
	
	резалт = новый Структура;
	
	Пока инд < всего Цикл
		ключПараметра = мПараметры.Получить(инд);
		ключПараметра = Прав(ключПараметра, СтрДлина(ключПараметра)-1);
		
		инд = инд + 1;
		
		Если ЗначениеЗаполнено(ключПараметра) Тогда
			резалт.Вставить(ключПараметра, ИСТИНА);
			Если(инд < всего) Тогда 
				возможноеЗначение = мПараметры.Получить(инд);
				Если Лев(возможноеЗначение, 1) <> "-" Тогда
					резалт[ключПараметра] = возможноеЗначение;
					инд = инд + 1;	
				КонецЕсли;
			КонецЕсли;	
		КонецЕсли;
	КонецЦикла;
	
	Возврат резалт;
КонецФункции

Функция ИмяФайлаОбработки()
	Возврат ЭтотОбъект.ИспользуемоеИмяФайла;
КонецФункции

Функция ПолучитьМаркерФоновогоПроцесса()
	Возврат "M_AUTO_B";
КонецФункции


Функция ПолучитьПароль1с() 
	Возврат "tabak123";
КонецФункции
Функция ПолучитьАргументыДляЗапуска1С(допАргументы)
	
	лСтр = "-"+СтрокаСоединенияИнформационнойБазы();
	лСтр = СтрЗаменить(лСтр,";"," -");
	лСтр = СтрЗаменить(лСтр,"="," ");
	лСтр = СтрЗаменить(лСтр, """", "");
	
	текущаяКонекция = РазобратьПараметры(лСтр);
	
	
	резалт = " /S "+текущаяКонекция.Srvr+"\"+текущаяКонекция.Ref+"";
	
	резалт = резалт + " /N Админ /P "+ПолучитьПароль1с();    
	резалт = резалт + " /RunModeOrdinaryApplication /DisableStartupMessages";
	резалт = резалт + " /Execute "+ИмяФайлаОбработки();
	
	Если ЛОЖЬ Тогда допАргументы = новый Структура; КонецЕсли;
	
	Если допАргументы <> неопределено тогда
		резалт = резалт	+ " /C """;
		Для каждого аргумент из допАргументы Цикл
			резалт = резалт	+ " -" + аргумент.Ключ;
			Если аргумент.Значение <> неопределено Тогда
				резалт = резалт	+ " " + аргумент.Значение;	
			КонецЕсли;
		КонецЦикла;  
		резалт = резалт	+ """"
	КонецЕсли;
	
	резалт = резалт + " "+ПолучитьМаркерФоновогоПроцесса()+"";
	Возврат резалт;
	//Сообщить(РазобратьПараметры(лСтр));
	
КонецФункции 

Функция ВыгрузкаПоОпцииВФоне(идентификаторОпции, датаНачала, датаОкончания)ЭКСПОРТ
	ПроверкаЛимитаПотоков();
	
	appOld = """"+КаталогПрограммы()+"1cv8.exe""";
	
	допАргументы = Новый Структура;
	допАргументы.Вставить("идентификаторОпции",идентификаторОпции);  
	
	шагВДнях = ЭтотОбъект.ПараллельнаяВыгрузка_ШагВДнях;
	_датаН = датаНачала;
	_датаК =  КонецДня(_датаН) + (60*60*24*шагВДнях);
	
	скд = ЭтотОбъект.ПолучитьМакет(идентификаторОпции);
	Если НЕ СКДСодержитПараметрДатаНиДатаК(скд) Тогда
		_датаН = датаОкончания - 1;
		_датаК = датаОкончания;
	КонецЕсли;	
	Пока _датаН < датаОкончания Цикл                                                    
		
		допАргументы.Вставить("датаНачала",Формат(_датаН, "ДФ=""ггггММддЧЧммсс"""));
		допАргументы.Вставить("датаОкончания",Формат(_датаК, "ДФ=""ггггММддЧЧммсс"""));
		
		connOldUT= ПолучитьАргументыДляЗапуска1С(допАргументы);
		командаЗапуска1С = appOld +" "+connOldUT;		                   
		Сообщить(СтрЗаменить(командаЗапуска1С, ПолучитьПароль1с(),"***"));
		ЗапуститьПриложение(командаЗапуска1С,,ложь,);
		
		Пауза(2);

		
		_датаН = КонецДня(_датаК)+1;	
		_датаК = КонецДня(_датаК + 60*60*24*шагВДнях);
		Если _датаК > датаОкончания Тогда
			_датаК = датаОкончания;
		КонецЕсли;
	КонецЦикла;
КонецФункции

Функция ПроверкаЛимитаПотоков()
	вФоне = ПолучитьКоличествоФоновыхПроцессов();
	Пока вФоне >= ЭтотОбъект.ПараллельнаяВыгрузка_КоличествоПотоков Цикл	
		//Сообщить("Уже запущено " + вФоне +" потоков");
		Пауза(10);  
		вФоне = ПолучитьКоличествоФоновыхПроцессов();
	КонецЦикла;
КонецФункции

Функция ПолучитьКоличествоФоновыхПроцессов()
	времФайл = ПолучитьИмяВременногоФайла();
	КомандаСистемы_Скрыто("wmic /OUTPUT:"""+времФайл+""" process where ""commandline like '%M_AUTO_B%'"" get processid, commandline");
	
	тд = Новый ТекстовыйДокумент;
	тд.Прочитать(времФайл);
	количествоПроцессов = тд.КоличествоСтрок() - 2;
	УдалитьФайлы(времФайл);
	
	ЭтотОбъект.ПараллельнаяВыгрузка_ТекущееКоличествоПотоков = количествоПроцессов; 
	Возврат количествоПроцессов;
КонецФункции

Процедура Пауза(Сек = 1) Экспорт
    Инфо = Новый СистемнаяИнформация();
    Если
        Инфо.ТипПлатформы = ТипПлатформы.Windows_x86 ИЛИ
        Инфо.ТипПлатформы = ТипПлатформы.Windows_x86_64
    Тогда
        КомандаСистемы_Скрыто("ping -n " + Формат(1 + Сек, "ЧДЦ=0; ЧГ=") + " 127.0.0.1"); // windows
    Иначе
        КомандаСистемы_Скрыто("ping -c " + Формат(1 + Сек, "ЧДЦ=0; ЧГ=") + " 127.0.0.1"); // linux
    КонецЕсли;
КонецПроцедуры 

Функция КомандаСистемы_Скрыто(команда, требуетсяОжидатьЗавершения = ИСТИНА)
	WshShell=Новый COMОбъект("WScript.Shell");
	WshShell.Run(команда,0, требуетсяОжидатьЗавершения);
	//WshShell.Run("cmd /c ping >> c:\test.txt", 0);
КонецФункции

////
Функция СтруктураВjson(Значение)  ЭКСПОРТ
	
	Если Значение = неопределено Тогда
		возврат "";
	КонецЕсли;
	
	
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, Значение);
	СтрJSON = ЗаписьJSON.Закрыть();
	
	возврат СтрJSON;
КонецФункции 

Функция ДатуВСтрокуСКЛ(дата)
	Возврат ФОРМАТ((дата),"ДФ=""ггггММдд ЧЧ:мм:сс""");	
КонецФункции

Функция СтрокаВАльяс(стр)
	альяс = стр; 
	альяс = СтрЗаменить(альяс," ","_");
	альяс = СтрЗаменить(альяс,"-","_");
	Возврат альяс;
КонецФУнкции

Функция ТаблицаЗначенийВМассивДанных(тз, добавлятьПредставленияСсылке = ложь)
	Если ЛОЖЬ Тогда тз = новый ТаблицаЗначений; КонецЕсли;
	
	мИсключениеИменаКолонокКакСтрока = новый Массив;
	мИсключениеИменаКолонокКакСтрока.Добавить("Регистратор");
	результ = новый Массив;
	Для Каждого стр из тз Цикл
		запись = новый Структура;
		
		Для Каждого колонка из тз.Колонки Цикл
			ключ = колонка.Имя;
			значение = стр[колонка.Имя];
			Если (значение = неопределено) ИЛИ (значение = Null) Тогда
				Если мИсключениеИменаКолонокКакСтрока.Найти(колонка.Имя) <> неопределено Тогда
					Если(колонка.ТипЗначения.Типы().Найти(Тип("Строка")))Тогда
						значение = "";
					ИначеЕсли(колонка.ТипЗначения.Типы().Найти(Тип("Число")))Тогда
						Значение = 0;
					ИначеЕсли(колонка.ТипЗначения.Типы().Найти(Тип("Булево")))Тогда
						Значение = ЛОЖЬ;
					КонецЕсли;
				Иначе
					Продолжить;
				КонецЕсли;
			ИначеЕсли ТипЗнч(значение) = тип("Булево") Тогда
				Если значение = Истина Тогда
					Значение = 1;
				Иначе
					Значение = 0;
				КонецЕсли;
			ИначеЕсли ТипЗнч(значение) = тип("Дата") Тогда
			ИначеЕсли ТипЗнч(значение) = тип("Строка") Тогда
			ИначеЕсли ТипЗнч(значение) = тип("Число") Тогда
			ИначеЕсли ТипЗнч(значение) = тип("СправочникСсылка.ЗначенияСвойствОбъектов") Тогда
				значение = Строка(значение);
			Иначе
				Попытка               
					значениеДо = значение;
					значение = Строка(значение.УникальныйИдентификатор());
					//значение = значение.УникальныйИдентификатор();      
					Если добавлятьПредставленияСсылке Тогда
						Если (ключ = "Ссылка") Тогда
							запись.Вставить(ключ+"Представление",Строка(значениеДо));
						КонецЕсли;
					КонецЕсли;
				Исключение
					значение = Строка(значение);
				Конецпопытки;
				
			КонецЕсли;
			
			запись.Вставить(ключ,значение);
		КонецЦикла;
		
		результ.Добавить(запись);
	КонецЦикла;
	
	Возврат результ;
КонецФункции


Процедура ДанныеВСиквел(массивДанных, имяТаблицы, where = "", replace = false, суфиксТмп = "")
	
	папка = "\\192.168.0.154\Volume_1\deploy\jsonToSql\";
	рандом = новый УникальныйИдентификатор();
	имяФайла = "" + рандом + ".json";	
	полныйПуть = папка + имяФайла; 
	
	табДокумент = новый ТекстовыйДокумент;
	табДокумент.УстановитьТекст(СтруктураВjson(массивДанных));
	табДокумент.Записать(полныйПуть, КодировкаТекста.ANSI);
	
	
	балк = ГенерацияSQL_BULK(массивДанных, полныйПуть, имяТаблицы, суфиксТмп); 
	
	
	
	Если балк <> неопределено Тогда
		ВыполниттьSQL(балк, ИСТИНА);	
		Попытка
			ВыполниттьSQL(ГенерацияSQL_INSERT_TRY(имяТаблицы), ЛОЖЬ);	
		Исключение	                                       
			
			sqlMerge = ГенерацияSQL_MERGE(имяТаблицы, where, replace, суфиксТмп);
			//Сообщить(sqlMerge);
			ВыполниттьSQL(sqlMerge, ИСТИНА);
		Конецпопытки;
		
		ВыполниттьSQL(ГенерацияSQL_DROP_Артефактов(имяТаблицы, суфиксТмп), ИСТИНА);
	КонецЕсли;
	УдалитьФайлы(папка,имяФайла);
	
КонецПроцедуры 

Процедура ВыполниттьSQL(запросSQL, выводитьЗапросПриОшибке = ЛОЖЬ)     
	Если Соединение = неопределено Тогда
			
		/////////////////////////////////////////
	    //Подключение к SQL-серверу
		Соединение  = Новый COMОбъект("ADODB.Connection");
		Соединение.ConnectionString =
        "driver={SQL Server};" +
        "server="+ИмяСервераSQL+";"+
        "uid="+ПользовательSQL+";"+
        "pwd="+ПарольSQL+";"+
        "database="+БазаДанныхSQL+";";
	    Соединение.ConnectionTimeout = 30;
	    Соединение.CommandTimeout = 60000;
	    //Открытие соединение
	    Соединение.Open();

	КонецЕсли;
	
	
	
    Команда     = Новый COMОбъект("ADODB.Command");
    Выборка     = Новый COMОбъект("ADODB.RecordSet");
	Команда.ActiveConnection   = Соединение;
	
	Попытка
		Соединение.Execute(запросSQL,,128);
	Исключение
		Если выводитьЗапросПриОшибке Тогда
			Сообщить(запросSQL);
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
КонецПроцедуры

Функция ГенерацияSQL_INSERT_TRY(имяТаблицы, суфиксТмп = "")
	Возврат "SELECT * INTO ["+имяТаблицы+"] FROM ["+ГенерацияИмениВременноТаблици(имяТаблицы, суфиксТмп)+"]";
КонецФункции

Функция ГенерацияSQL_MERGE(имяТаблицы, where = неопределено,replace=false, суфиксТмп = "")
	
	инсертСоСписокмполей =
	"declare @tableFrom VARCHAR(255) = '["+ГенерацияИмениВременноТаблици(имяТаблицы, суфиксТмп)+"]'
	|declare @tableTo VARCHAR(255) = '["+имяТаблицы+"]'
	|
	|
	|SET @tableFrom = REPLACE(REPLACE(@tableFrom,'[',''),']','')
	|SET @tableTo = REPLACE(REPLACE(@tableTo,'[',''),']','')
	|declare @results VARCHAR(MAX)
	|
	|SELECT @results = coalesce(@results + ',', '') +  '['+[name]+']'
	|FROM sys.all_columns c WHERE object_id = OBJECT_ID(@tableFrom)
	|
	|SET @results = 'INSERT INTO ['+@tableTo+'] ('+@results+') SELECT '+@results+' FROM ['+@tableFrom+']' 
	|--PRINT @results                                                           
	|EXEC (@results)
	|";
	
	Если replace Тогда
		Возврат "
		|BEGIN TRAN
		|DELETE FROM ["+имяТаблицы+"]  
		//|INSERT INTO ["+имяТаблицы+"] SELECT * FROM ["+ГенерацияИмениВременноТаблици(имяТаблицы, суфиксТмп)+"]
		|"+инсертСоСписокмполей+"
		|COMMIT TRAN";
	КонецЕсли;
	
	Если ЗначениеЗаполнено(where) Тогда
		Возврат "
		|BEGIN TRAN
		|DELETE FROM ["+имяТаблицы+"] WHERE "+where+" 
		//|INSERT INTO ["+имяТаблицы+"] SELECT * FROM ["+ГенерацияИмениВременноТаблици(имяТаблицы, суфиксТмп)+"]
		|"+инсертСоСписокмполей+"
		|COMMIT TRAN";
	КонецЕсли;
	
	
	//
	//Возврат "DECLARE @output nvarchar(max) 
	//		|EXEC sp_generate_merge 
	//		|	@table_name = '"+имяТаблицы+"_tmp', 
	//		|	@target_table = '"+имяТаблицы+"',
	//		|	@cols_to_join_on = """+имяПолейКлючей+""",
	//		|	@batch_separator = null,
	//		|	@results_to_text = 1,
	//		|	@include_use_db = 0,
	//		|	@output = @output output
	//		|EXEC(@output)";
КонецФункции

Функция ГенерацияИмениВременноТаблици(имяТаблицы, суфиксТмп="")
	Возврат ""+имяТаблицы+  "_"+суфиксТмп+"_tmp";
КонецФункции

Функция ГенерацияSQL_DROP_Артефактов(имяТаблицы, суфиксТмп)
	Возврат "DROP TABLE ["+ГенерацияИмениВременноТаблици(имяТаблицы, суфиксТмп)+"]"
КонецФункции

Функция ГенерацияSQL_BULK(массивДанных, имяФайла, имяТаблицы, суфиксТмп)
	Если ЛОЖЬ Тогда массивДанных = Новый Массив; КонецЕсли;
	Если массивДанных.Количество() = 0 Тогда
		Возврат неопределено;
	КонецЕсли;
	
	запись = массивДанных[0];
	Если ЛОЖЬ Тогда запись = новый Структура; КонецЕсли;
	
	строкаWITH = "";
	
	Для Каждого эл из запись Цикл
		имяПоля = эл.Ключ;
		//имяТипа = "nvarchar(255)";
		имяТипа = "varchar(255)";
		этоГУИД = ложь;
		Попытка
			ун = Новый УникальныйИдентификатор(эл.Значение);
			этоГУИД = истина;
		Исключение
		КонецПопытки;
		Если ТипЗнч(эл.Значение)=Тип("Строка") и этоГУИД Тогда
			имяТипа = "uniqueidentifier";
		ИначеЕсли ТипЗнч(эл.Значение)=Тип("Строка") Тогда
			//имяТипа = "nvarchar(255)";
			имяТипа = "varchar(255)";
		ИначеЕсли ТипЗнч(эл.Значение)=Тип("Число") Тогда
			имяТипа = "decimal(15,5)";
		ИначеЕсли ТипЗнч(эл.Значение)=Тип("Дата") Тогда
			имяТипа = "datetime2";
		ИначеЕсли ТипЗнч(эл.Значение)=Тип("Булево") Тогда
			имяТипа = "bit";
		Иначе
			//имяТипа = "nvarchar(255)";
			имяТипа = "varchar(255)";
		КонецЕсли;;
		
		строкаWITH = строкаWITH + "["+имяПоля+"] "+имяТипа + ",";		
	КонецЦикла;
	строкаWITH = Лев(строкаWITH,СтрДлина(строкаWITH) - 1);
	
	Возврат "
	|SELECT 
	|	T.*
	|INTO ["+ГенерацияИмениВременноТаблици(имяТаблицы, суфиксТмп)+"]
	|FROM OPENROWSET (BULK '"+имяФайла+"', SINGLE_CLOB) as j
	|	CROSS APPLY OPENJSON(BulkColumn)
	|	WITH(
	|		"+строкаWITH+"
	|	) AS T";

КонецФункции

Функция ТабличныйДокументИзТаблицы(массивДанных) ЭКСПОРТ
	табДокумент = Новый ТабличныйДокумент;
	Если ЛОЖЬ Тогда массивДанных = Новый Массив; КонецЕсли;
	
	номерКолонки = 1;
	номерСтроки = 1;
	
	Для Каждого стр из массивДанных Цикл
		Если ЛОЖЬ Тогда стр = новый Структура; КонецЕсли;
		Если номерСтроки = 1 Тогда
			Для Каждого эл из стр Цикл
				табДокумент.Область(номерСтроки,номерКолонки,номерСтроки,номерКолонки).Текст = эл.Ключ;
				номерКолонки = номерКолонки + 1;
			КонецЦикла;
		КонецЕсли;
		
		номерКолонки = 1;
		номерСтроки = номерСтроки + 1;
		Для Каждого эл из стр Цикл
			табДокумент.Область(номерСтроки,номерКолонки,номерСтроки,номерКолонки).Текст = эл.Значение;
			номерКолонки = номерКолонки + 1;
		КонецЦикла;
		
	КонецЦикла;
	Возврат табДокумент;    
КонецФУнкции


////  
//Инициализация переменных 
//ПользовательSQL = "sa";
//ПарольSQL = "Pdv4753!";
//ИмяСервераSQL = "DBSERV4";

ИмяСервераSQL = "OLAP";
ПользовательSQL = "sync_1c";
ПарольSQL = "6";
БазаДанныхSQL = "olap_dw";
////                               

Для Каждого макет из ЭтотОбъект.Метаданные().Макеты Цикл
	Если Строка(макет.ТипМакета) = "СхемаКомпоновкиДанных" И Прав(макет.Имя,9)="_Основной" Тогда
		нСтрОпции = ЭтотОбъект.ОпцииВыгрузки.Добавить();
		нСтрОпции.Выбран = истина;
		нСтрОпции.ИдентификаторОпции = макет.Имя;	
		нСтрОпции.Опция = СтрЗаменить(макет.Синоним,"_"," "); 
	КонецЕсли;
КонецЦикла; 

ЭтотОбъект.ДатаОкончания = НачалоДня(ТекущаяДата())-1;
ЭтотОбъект.ДатаНачала = ЭтотОбъект.ДатаОкончания -( 60 * 60 * 24 * 7);
//мОпцииВыгрузки = новый Массив();
//мОпцииВыгрузки.Добавить("Справочник_Номенклатура");
//мОпцииВыгрузки.Добавить("Справочник_Контрагенты");
//мОпцииВыгрузки.Добавить("Документ_ООРП");
//мОпцииВыгрузки.Добавить("Документ_Реализация_Товаров_и_Услуг");


//Для Каждого опция из мОпцииВыгрузки Цикл
//	
//	нСтрОпции = ЭтотОбъект.ОпцииВыгрузки.Добавить();
//	нСтрОпции.Выбран = истина;
//	нСтрОпции.ИдентификаторОпции = опция;
//	нСтрОпции.Опция = СтрЗаменить(опция,"_"," ");
//КонецЦикла;      


параметрыЗапуск = РазобратьПараметры(ПараметрЗапуска); 
Если ЛОЖЬ Тогда параметрыЗапуск = новый Структура; КонецЕсли;
Сообщить(СтруктураВjson(параметрыЗапуск));

Если параметрыЗапуск.Свойство("датаНачала") Тогда
	Попытка ЭтотОбъект.ДатаНачала = Дата(параметрыЗапуск.датаНачала); Исключение КонецПопытки;
КонецЕсли;
Если параметрыЗапуск.Свойство("датаОкончания") Тогда  
	Попытка ЭтотОбъект.ДатаОкончания = Дата(параметрыЗапуск.датаОкончания); Исключение КонецПопытки;
КонецЕсли;


Если параметрыЗапуск.Свойство("идентификаторОпции") Тогда
	Для Каждого опция из ЭтотОбъект.ОпцииВыгрузки Цикл
		опция.Выбран = ?(опция.ИдентификаторОпции = параметрыЗапуск.идентификаторОпции, ИСТИНА, ЛОЖЬ);
	Конеццикла;
	НачатьВыгрузку();
	ЗавершитьРаботуСистемы(Ложь);
Иначе
	//ЭтотОбъект.ПараллельнаяВыгрузка = ИСТИНА;
	ЭтотОбъект.ПараллельнаяВыгрузка = ЛОЖЬ;
	ЭтотОбъект.ПараллельнаяВыгрузка_КоличествоПотоков = 12;
	ЭтотОбъект.ПараллельнаяВыгрузка_ШагВДнях = 2;
КонецЕсли;
