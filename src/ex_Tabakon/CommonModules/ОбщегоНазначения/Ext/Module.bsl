Функция ПолучитьВерсиюРасширения() экспорт 	
	
	результ = "";
	
	НужнаяПоз = найти(ПараметрыСеанса.ПодключенныеРасширения,")");
	результ   = Сред(ПараметрыСеанса.ПодключенныеРасширения,1,НужнаяПоз);
	результ = СтрЗаменить(результ,")","");
	результ = СтрЗаменить(результ,"(","");

	Возврат результ;
	
	//мРасширений = РасширенияКонфигурации.Получить();
	//
	//Для Каждого расширение из мРасширений Цикл
	//	результ = результ + ?(ЗначениеЗаполнено(результ),"; ","")+расширение.Имя+":"+расширение.Версия;
	//КонецЦикла;
	//
	//возврат результ;
	
КонецФункции



Функция ПолучитьМагазин() ЭКСПОРТ
	Возврат ПолучитьМагазинИзООРП();
КонецФункции



Функция ПолучитьМагазинИзООРП() ЭКСПОРТ
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
	               |	ОтчетОРозничныхПродажах.Магазин КАК Магазин
	               |ИЗ
	               |	Документ.ОтчетОРозничныхПродажах КАК ОтчетОРозничныхПродажах
	               |ГДЕ
	               |	ОтчетОРозничныхПродажах.Проведен = ИСТИНА
	               |
	               |УПОРЯДОЧИТЬ ПО
	               |	ОтчетОРозничныхПродажах.Дата УБЫВ";
	
	рез = Запрос.Выполнить().Выгрузить();
	
	Если рез.Количество()>0 тогда
		Возврат Рез[0].Магазин;
	иначе
		Возврат Справочники.Магазины.ПустаяСсылка();
	КонецЕсли;
КонецФункции

Функция ПолучитьСкладИзООРП() ЭКСПОРТ
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
	               |	ОтчетОРозничныхПродажах.Магазин.СкладПродажи КАК Склад
	               |ИЗ
	               |	Документ.ОтчетОРозничныхПродажах КАК ОтчетОРозничныхПродажах
	               |ГДЕ
	               |	ОтчетОРозничныхПродажах.Проведен = ИСТИНА
	               |
	               |УПОРЯДОЧИТЬ ПО
	               |	ОтчетОРозничныхПродажах.Дата УБЫВ";
	
	рез = Запрос.Выполнить().Выгрузить();
	
	Если рез.Количество()>0 тогда
		Возврат Рез[0].Склад;
	иначе
		Возврат Справочники.Склады.ПустаяСсылка();
	КонецЕсли;
КонецФункции

Функция ПолучитьКассаККМИзООРП() ЭКСПОРТ
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
	               |	ОтчетОРозничныхПродажах.КассаККМ КАК КассаККМ
	               |ИЗ
	               |	Документ.ОтчетОРозничныхПродажах КАК ОтчетОРозничныхПродажах
	               |ГДЕ
	               |	ОтчетОРозничныхПродажах.Проведен = ИСТИНА
	               |
	               |УПОРЯДОЧИТЬ ПО
	               |	ОтчетОРозничныхПродажах.Дата УБЫВ";
	
	рез = Запрос.Выполнить().Выгрузить();
	
	Если рез.Количество()>0 тогда
		Возврат Рез[0].КассаККМ;
	иначе
		Возврат Справочники.Склады.ПустаяСсылка();
	КонецЕсли;
КонецФункции

Функция ПолучитьКассуИзПКО() ЭКСПОРТ
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
	               |	ПриходныйКассовыйОрдер.Касса КАК Касса
	               |ИЗ
	               |	Документ.ПриходныйКассовыйОрдер КАК ПриходныйКассовыйОрдер
	               |ГДЕ
	               |	ПриходныйКассовыйОрдер.Проведен = ИСТИНА
	               |	И НЕ ПриходныйКассовыйОрдер.Касса.ПометкаУдаления
	               |	И ПриходныйКассовыйОрдер.Касса <> &Касса
	               |
	               |УПОРЯДОЧИТЬ ПО
	               |	ПриходныйКассовыйОрдер.Дата УБЫВ";
	Запрос.УстановитьПараметр("Касса",Справочники.Кассы.ПустаяСсылка());
	
	рез = Запрос.Выполнить().Выгрузить();
	
	Если рез.Количество()>0 тогда
		Возврат Рез[0].Касса;
	иначе
		Возврат Справочники.Кассы.ПустаяСсылка();
	КонецЕсли;
КонецФункции



Функция СтруктураВjson_Общая(Значение) экспорт

	Если Значение = неопределено Тогда
		возврат "";
	КонецЕсли; 	
	
    ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, Значение);
	СтрJSON = ЗаписьJSON.Закрыть();
	
	возврат СтрJSON;

КонецФункции

Функция ПолучитьСтруктуруПодключенияFTP() экспорт
	СтруктураВозврата	=	новый Структура;
	
	Запрос	=	Новый запрос("ВЫБРАТЬ
	      	 	             |	НастройкиТранспортаОбменаДанными.Корреспондент КАК Корреспондент,
	      	 	             |	НастройкиТранспортаОбменаДанными.FTPСоединениеПуть КАК FTPСоединениеПуть,
	      	 	             |	НастройкиТранспортаОбменаДанными.FTPСоединениеПользователь КАК FTPСоединениеПользователь,
	      	 	             |	НастройкиТранспортаОбменаДанными.FTPСоединениеПорт КАК FTPСоединениеПорт
	      	 	             |ИЗ
	      	 	             |	РегистрСведений.НастройкиТранспортаОбменаДанными КАК НастройкиТранспортаОбменаДанными");
	
	Рез = запрос.Выполнить().Выгрузить();
	
	для каждого Строка из рез цикл
		Если ЗначениеЗаполнено(Строка.Корреспондент) тогда
			Если Строка.Корреспондент.пометкаУдаления тогда Продолжить; КонецЕсли;
		КонецЕсли;
		
		Если ТипЗнч(Строка.Корреспондент) = Тип("ПланОбменаСсылка.ОбменРозницаУправлениеТорговлей103") тогда
			Пароль			=	ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища(Строка.Корреспондент, "FTPСоединениеПароль");
			НужПользователь	=	Строка.FTPСоединениеПользователь;
			Порт			=	Строка.FTPСоединениеПорт;

			
			СерверИКаталогНаСервере = ОбменДаннымиСервер.FTPИмяСервераИПуть(СокрЛП(Строка.FTPСоединениеПуть));
			
			ИмяFTPСервера			= СерверИКаталогНаСервере.Сервер;
			КаталогНаСервере 		= СерверИКаталогНаСервере.Путь;
			
			СтруктураВозврата.Вставить("ИмяFTPСервера",ИмяFTPСервера);
			СтруктураВозврата.Вставить("КаталогНаСервере",КаталогНаСервере);
			СтруктураВозврата.Вставить("Пользователь",НужПользователь);
			СтруктураВозврата.Вставить("Пароль",Пароль);
			СтруктураВозврата.Вставить("Порт",Порт);
			
			Возврат СтруктураВозврата;
			
			Прервать;
		КонецЕсли;
	КонецЦикла;

	Возврат Неопределено;
			
КонецФункции


Функция ПолучитьТерминал(РабочееМесто) экспорт
	СписокУстройств = МенеджерОборудованияВызовСервера.ОборудованиеПоПараметрам( , , РабочееМесто);
	
	Для каждого Строка из СписокУстройств цикл
		Если Строка.ТипОборудования = Перечисления.ТипыПодключаемогоОборудования.ЭквайринговыйТерминал тогда
			
			Запрос	=	Новый запрос("ВЫБРАТЬ
			      	 	             |	ЭквайринговыеТерминалы.Ссылка КАК Ссылка
			      	 	             |ИЗ
			      	 	             |	Справочник.ЭквайринговыеТерминалы КАК ЭквайринговыеТерминалы
			      	 	             |ГДЕ
			      	 	             |	НЕ ЭквайринговыеТерминалы.ПометкаУдаления
			      	 	             |	И (ЭквайринговыеТерминалы.ПодключаемоеОборудование = &ПодключаемоеОборудование
			      	 	             |			ИЛИ ЭквайринговыеТерминалы.ИспользоватьБезПодключенияОборудования)");
			Запрос.УстановитьПараметр("ПодключаемоеОборудование",Строка.Ссылка);
			
			Рез = Запрос.Выполнить().Выгрузить();
			Если рез.Количество() >0 тогда
				Возврат Рез[0].Ссылка;
			иначе
				Возврат Неопределено;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;

КонецФункции

Функция ПолучитьТЗИзМакета(ТабДок, КолонкаИндекса = 1) Экспорт
    
    ТаблицаДанных = Новый ТаблицаЗначений;
    НомерКолонки = 0;
    Пока Истина Цикл
        НомерКолонки = НомерКолонки + 1;
        ИмяКолонки = ТабДок.Область(1, НомерКолонки).Текст;
        Если ПустаяСтрока(ИмяКолонки) Тогда
            Прервать;
        КонецЕсли;        
        ТаблицаДанных.Колонки.Добавить(ИмяКолонки);
    КонецЦикла;
    
    СчетчикКолонок = НомерКолонки - 1;
    
    НомерСтроки = 1; ФлагПрерывания = Ложь;
	Если не СчетчикКолонок = 0 тогда
	    Пока Истина Цикл
	        НомерСтроки = НомерСтроки + 1;
	        Стр = ТаблицаДанных.Добавить();
	        
	        Для А = 1 ПО СчетчикКолонок Цикл
	            ТекстКолонки = ТабДок.Область(НомерСтроки, А).Текст;
	            Если ПустаяСтрока(ТекстКолонки) Тогда
	                Если А = КолонкаИндекса Тогда
	                    Флагпрерывания = Истина;
	                    ТаблицаДанных.Удалить(Стр);
	                КонецЕсли;
	            Иначе
	                Стр[А - 1] = ТекстКолонки
	            КонецЕсли;
	            
	            Если Флагпрерывания Тогда
	                Прервать
	            КонецЕсли;
	        КонецЦикла;
	        
	        Если Флагпрерывания Тогда
	            Прервать
	        КонецЕсли;
		КонецЦикла;
	КонецЕсли;
    
    Возврат ТаблицаДанных
КонецФункции

Функция jsonВСтруктура_Общая(Значение) экспорт
	Если ЗначениеЗаполнено(СокрЛП(Значение)) Тогда
		
	    ЧтениеJSON = Новый ЧтениеJSON;
	    ЧтениеJSON.УстановитьСтроку(Значение);
	    Возврат ПрочитатьJSON(ЧтениеJSON, Ложь);
		
	Иначе
		Возврат Новый Структура();
	КонецЕсли;

КонецФункции

Функция ЭтоМаркированнаяНоменклатура(Номенклатура) экспорт
	возврат Найти(Номенклатура.ВидНоменклатуры.Наименование,"Табак (х)") или Номенклатура.ОсобенностьУчета = Перечисления.ОсобенностиУчетаНоменклатуры.ТабачнаяПродукция;	
КонецФункции

Функция ПолучитьЗначениеТБККонстанты(ИмяКонстанты) экспорт
	Запрос	=	Новый Запрос("ВЫБРАТЬ
	      	 	             |	ТБК_Константы.ЗначениеКонстанты КАК ЗначениеКонстанты
	      	 	             |ИЗ
	      	 	             |	РегистрСведений.ТБК_Константы КАК ТБК_Константы
	      	 	             |ГДЕ
	      	 	             |	ТБК_Константы.ИмяКонстанты = &ИмяКонстанты");
	Запрос.УстановитьПараметр("ИмяКонстанты",ИмяКонстанты);
	
	Рез = Запрос.Выполнить().Выгрузить();
	Если Рез.Количество() = 1 тогда
		Возврат Рез[0].ЗначениеКонстанты;
	КонецЕсли;

	Возврат Неопределено;	
КонецФункции

Функция РазобратьДату(ИзмДата) экспорт
	Возврат Дата(Сред(ИзмДата,7,4)+Сред(ИзмДата,4,2)+Сред(ИзмДата,0,2));	       	
КонецФункции   

Функция УдалениеНезначимыхСимволов (ВходящаяСтрока) Экспорт 

	ВходящаяСтрока = СокрЛП(ВходящаяСтрока);
    ДлинаСтроки = СтрДлина(ВходящаяСтрока);
    КонечнаяСтрока = Строка("");
     
      Пока ДлинаСтроки > 0 Цикл
           
            ПервыйСимвол = Лев(ВходящаяСтрока, 1);
           
            Если Не ПустаяСтрока(ПервыйСимвол) Тогда
                  КонечнаяСтрока = КонечнаяСтрока + ПервыйСимвол;
                  Отступ = 2;
                  ДлинаСтроки = ДлинаСтроки - 1;
          Иначе
                  КонечнаяСтрока = КонечнаяСтрока + "";
                  ВходящаяСтрока = СокрЛ(ВходящаяСтрока);
                  ДлинаСтроки = СтрДлина(ВходящаяСтрока);
                  Отступ = 1;
            КонецЕсли;
           
            Если ДлинаСтроки > 1 тогда
                  ВходящаяСтрока = Сред(ВходящаяСтрока, Отступ, ДлинаСтроки);
            Иначе
              КонечнаяСтрока = КонечнаяСтрока + Сред(ВходящаяСтрока, Отступ, 1);
                  ДлинаСтроки = 0;
            КонецЕсли;
           
      КонецЦикла;
     
      Возврат КонечнаяСтрока;
КонецФункции
	
Функция УстановитьЗначениеТБККонстанты(ИмяКонстанты, ЗначениеКонстанты) экспорт
	
	Рег = РегистрыСведений.ТБК_Константы.СоздатьНаборЗаписей();
	Рег.Отбор.ИмяКонстанты.Установить(ИмяКонстанты);
	НоваяСтр	=	Рег.Добавить();
	НоваяСтр.ЗначениеКонстанты	=	ЗначениеКонстанты;
	НоваяСтр.ИмяКонстанты		=	ИмяКонстанты;
	рег.Записать();
	
КонецФункции

#Область ТекущаяДатаИзИнета

Функция ТекущаяДатаИзИнтернета() Экспорт

	//Тело POST-запроса, сюда yandex вернет ответ 
	ТелоPOSTЗапроса = "";
	
	//POST-запрос на сервер-приёмник
	СерверПриемник = "www.yandex.ru"; //имя сервера без протокола (http) и порта
	
	// сформируем пустой запрос, нам от yandex ничего не нужно, а при пустом запросе в ответ он как и пошлет текущее дату-время
	ЗаголовкиHTTP = Новый Соответствие;
	ЗаголовкиHTTP.Вставить("Content-Type", "text/html;charset=UTF-8");

	Таймаут = 120;
	SSL =  Новый ЗащищенноеСоединениеOpenSSL();
	НТТР = Новый HTTPСоединение(СерверПриемник, , , , , Таймаут, SSL);

	Попытка
		//Формируем HTTP запрос
		ЗапросHTTP = Новый HTTPЗапрос("", ЗаголовкиHTTP);
		ЗапросHTTP.УстановитьТелоИзСтроки(ТелоPOSTЗапроса); //Устанавливает строку, из которого будет прочитано тело POST-запроса.
		
		//Ответ от сервера получим в возвращаемом значении типа HTTPОтвет
		ОтветHTTP = НТТР.ОтправитьДляОбработки(ЗапросHTTP);
	Исключение
		//ТекстСообщения = НСтр("ru = 'Неудачная попытка соединения с '")  + СерверПриемник + ": " + ОписаниеОшибки();
		//Сообщить(ТекстСообщения);
		Возврат ТекущаяДата();
	КонецПопытки;
	
	ЗаголовкиОтвета = ОтветHTTP.Заголовки;
	Если ЗаголовкиОтвета.Количество() > 0 Тогда
		Для каждого КлючИЗначение Из ЗаголовкиОтвета Цикл
			// в ответе много всякого, но нас интересует только DATE
			Если КлючИЗначение.Ключ = "Date" Тогда
				//Сообщить("Дата = " +РаспарситьСтрокуЗначения(КлючИЗначение.Значение, Истина));
				//Сообщить("ДатаВремя = " +РаспарситьСтрокуЗначения(КлючИЗначение.Значение, Ложь));
				Возврат РаспарситьСтрокуЗначения(КлючИЗначение.Значение, Ложь) 
				//Прервать;
			КонецЕсли;
		КонецЦикла; //Для каждого КлючИЗначение Из ЗаголовкиОтвета
	КонецЕсли;
	
	ОтветHTTP = NULL;	

КонецФункции

Функция ВернутьЧисловойСтрокой(пМесяц)
	
	Если Найти(НРег(пМесяц), "jan") > 0 Тогда
		Возврат "01";
	ИначеЕсли Найти(НРег(пМесяц), "feb") > 0 Тогда
		Возврат "02";
	ИначеЕсли Найти(НРег(пМесяц), "mar") > 0 Тогда
		Возврат "03";
	ИначеЕсли Найти(НРег(пМесяц), "apr") > 0 Тогда
		Возврат "04";
	ИначеЕсли Найти(НРег(пМесяц), "may") > 0 Тогда
		Возврат "05";
	ИначеЕсли Найти(НРег(пМесяц), "jun") > 0 Тогда
		Возврат "06";
	ИначеЕсли Найти(НРег(пМесяц), "jul") > 0 Тогда
		Возврат "07";
	ИначеЕсли Найти(НРег(пМесяц), "aug") > 0 Тогда
		Возврат "08";
	ИначеЕсли Найти(НРег(пМесяц), "sep") > 0 Тогда
		Возврат "09";
	ИначеЕсли Найти(НРег(пМесяц), "oct") > 0 Тогда
		Возврат "10";
	ИначеЕсли Найти(НРег(пМесяц), "nov") > 0 Тогда
		Возврат "11";
	ИначеЕсли Найти(НРег(пМесяц), "dec") > 0 Тогда
		Возврат "12";
	КонецЕсли;
	
КонецФункции

Функция РаспарситьСтрокуЗначения(пЗначение, ТолькоДата = Истина)
	// строка значения заголовка типа DATE  = "Tue, 27 Dec 2016 12:12:49 GMT"
	
	СтрокаДата = "";
	разделитель = ",";
	разделительПробел = " ";
    // местное отклонение по часовому поясу от Гринвича, в примере для простоты объявлено прямо в коде, но рекомендуется выносить в параметры или в реквизиты
	ОтклонениеПоЧасововмуПоясу = 3; 
	
	// отсекаем день недели - остается "27 Dec 2016 12:12:49 GMT"
	позицияРазделитель = Найти(пЗначение, разделитель);
	СтрокаДатаВремя = СокрЛП(Сред(пЗначение, позицияРазделитель+1));
	
	// получаем значение номера дня  - "27"
	позицияРазделительПробел = Найти(СтрокаДатаВремя, разделительПробел);
	СтрокаДень = СокрЛП(Сред(СтрокаДатаВремя, 1, позицияРазделительПробел-1));
	
	// отсекаем номер дня - остается "Dec 2016 12:12:49 GMT"
	СтрокаДатаВремя = СокрЛП(Сред(СтрокаДатаВремя, позицияРазделительПробел+1));
	
	// получаем номер месяца - "Dec", после преобразорвания - "12"
	позицияРазделительПробел = Найти(СтрокаДатаВремя, разделительПробел);
	СтрокаМесяц = СокрЛП(Сред(СтрокаДатаВремя, 1, позицияРазделительПробел-1));
	СтрокаМесяц = ВернутьЧисловойСтрокой(СтрокаМесяц); 
	
	// отсекаем номер месяца - остается "2016 12:12:49 GMT"
	СтрокаДатаВремя = СокрЛП(Сред(СтрокаДатаВремя, позицияРазделительПробел+1));
	
	// получаем номер года - "2016"
	позицияРазделительПробел = Найти(СтрокаДатаВремя, разделительПробел);
	СтрокаГод = СокрЛП(Сред(СтрокаДатаВремя, 1, позицияРазделительПробел-1));
	
	// вычислили дату, если запрашивали только ее, возвращаем
	Если ТолькоДата Тогда
		Возврат Дата(СтрокаГод+СтрокаМесяц+СтрокаДень);
	КонецЕсли;
	
	// вычисляем время
	// отсекам номер года - остается "12:12:49 GMT"
	СтрокаДатаВремя = СокрЛП(Сред(СтрокаДатаВремя, позицияРазделительПробел+1));
	
	// получаем время - "12:12:49", после преобразования - "121249"
	позицияРазделительПробел = Найти(СтрокаДатаВремя, разделительПробел);
	лСтрокаВремя = СокрЛП(Сред(СтрокаДатаВремя, 1, позицияРазделительПробел-1));
	лСтрокаВремя = СтрЗаменить(лСтрокаВремя, ":", "");
	
	// расчитываем время с учетом часового пояса
	лЧасы = Число(Сред(лСтрокаВремя, 1, 2));
	лОстальное = Сред(лСтрокаВремя, 3);
	лЧасы = лЧасы + ОтклонениеПоЧасововмуПоясу;
	СтрокаВремя = Строка(лЧасы) + лОстальное;
	СтрокаВремя = ?(СтрДлина(СтрокаВремя) = 6, СтрокаВремя, "0" + СтрокаВремя);
	
	// возвращаем полный формат даты с временем
	Возврат Дата(СтрокаГод+СтрокаМесяц+СтрокаДень+СтрокаВремя);
	
КонецФункции
	
#КонецОбласти
//КонецМарк